package de.ioexception.www.server.impl;

import de.ioexception.www.http.HttpRequest;
import de.ioexception.www.http.HttpResponse;
import de.ioexception.www.http.HttpStatusCode;
import de.ioexception.www.http.impl.BasicHttpResponse;
import java.net.Socket;
import java.text.FieldPosition;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import util.Base64;

/**
 *
 * @author Scott Wakeling
 */
public class DigestAuthHttpWorker extends BasicHttpWorker {

    private static final Map<String, String> authentications;
    private static final String realm = "Protected Area";

    static {
        authentications = new HashMap<String, String>();
        authentications.put("test", "secret");
        authentications.put("user", "1234");
    }

    ;

    public DigestAuthHttpWorker(Socket socket, BasicHttpServer server) {
        super(socket, server);
    }

    @Override
    protected HttpResponse handleRequest(HttpRequest request) {
        if (request.getHeaders().containsKey("Authorization")) {
            String authValue = request.getHeaders().get("Authorization");
            String[] authValues = authValue.split(" ", 2);
            String type = authValues[0];
            String values = authValues[1];
            if (type.equalsIgnoreCase("Digest")) {
                DigestAuthCredentials credentials = new DigestAuthCredentials(values);
                if (credentials.getUsername() != null) {
                    if (authentications.containsKey(credentials.getUsername())) {
                        //  Using the provided user's password, calculate the expected MD5 response digest
                        //  and compare to what has arrived in the header, did they use the right password
                        //  to construct their response hash?
                        String expResponse = credentials.calcExpectedResponse(authentications.get(credentials.getUsername()), request.getHttpMethod());
                        while (expResponse.length() < 32) {
                            expResponse = "0" + expResponse;
                        }
                        if (credentials.getResponse().equals(expResponse)) {
                            if (nonceValid(credentials.getNonce())) {
                                return super.handleRequest(request);
                            }

                        }
                    }
                }
            }
        }

        //  TODO: Authentication-Info header line?
        //  TODO: Specify MD5 as algorithm in header?
        //  TODO: qop, nc work
        BasicHttpResponse response = new BasicHttpResponse();
        response.setStatusCode(HttpStatusCode.UNAUTHORIZED);
        response.getHeaders().put("WWW-Authenticate", "Digest realm=\"" + realm + "\", qop=\"auth\", nonce=\"" + generateNonce() + "\"");
        return response;
    }

    /**
     * Generates a nonce value
     *
     * TODO: remember recently generated nonce values in a LRUCache
     *
     * @return A Base64 encoded nonce value
     */
    static String generateNonce() {
        Date now = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat();
        String nonce = sdf.format(now);
        return Base64.encodeToString(nonce.getBytes(), false);
    }

    /**
     * Checks a Base64 encoded nonce value for validity, at present this is a
     * simple 5 minute lifespan
     *
     * TODO: Only validate nonce values that can be found in a LRUCache of previously generated nonces
     *
     * @param nonce - A nonce value, as generated by generateNonce() and returned by a client
     * @return
     */
    static boolean nonceValid(String nonce) {
        byte[] bytes = Base64.decode(nonce);
        if (bytes != null && bytes.length > 0)
        {
            String nonceString = new String(bytes);
            try {
                SimpleDateFormat sdf = new SimpleDateFormat();
                Date then = sdf.parse(nonceString);
                Date now = new Date();
                if (now.after(then) && (now.getTime() - then.getTime() < 300000)) {
                    return true;
                }
            } catch (ParseException ex) {
                //  Definitely not a valid nonce
            }
        }
        return false;
    }
}
